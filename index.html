<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Never* Use Arrays</title>

	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/reveal.css" />
<!--	<link rel="stylesheet" href="css/theme/black.css">-->

  <link rel="stylesheet" href="platform/platformsh.css" />

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

  <style type="text/css">

    p.challenge-q {
      color: blue;
    }

    p.challenge-a {
      color: green;
    }
  </style>

</head>
<body class="skin-blue">
<div class="reveal">
  <footer>
    <img class="logo" src="platform/logos/platformsh-logo-black.svg" alt="Platform.sh" />
    <span class="name">@Crell</span>
  </footer>
	<div class="slides">
    <section class="title">
      <h1>Never* Use Arrays</h1>
    </section>

    <section id="presenter">
      <h2>Larry Garfield</h2>
      <h2><a href="https://twitter.com/Crell">@Crell</a></h2>
      <div class="layout-col vcentered">
        <img src="assets/larry-olaf-hug.jpg" alt="Larry implements Huggable" style="width: 350px; margin: 0" />
        <ul style="text-wrap: none">
          <li>Director of DX, <a href="http://www.platform.sh/">Platform.sh</a></li>
          <li style="margin-top: 1em;">PHP-FIG Core Committee</li>
          <li style="margin-top: 1em;"><code>implements Huggable</code></li>
        </ul>
      </div>
    </section>

    <section>
      <section>
        <!-- misaligned, come back to this. -->
        <p style="font-size: 4rem;">array(<img src="assets/php-logo.svg" style="height: 200px; text-align: center;" alt="PHP" data-credit="https://commons.wikimedia.org/wiki/File:PHP-logo.svg" />)</p>
        <aside class="notes">
          <ul>
            <li>PHP loves arrays</li>
            <li>The iconic PHP-ism</li>
            <li>Used everywhere</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="oversize">They come with an <code>array</code> of problems.</p>
        <div class="fragment"><img src="assets/picard-facepalm.jpg" class="meme" alt="The jokes will be that bad."></div>
        <aside class="notes">
          <ul>
            <li>Yes, the jokes will be that bad.</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="oversize">They come with an <code>array</code> of problems.</p>
        <ul>
          <li>Inconsistent behavior</li>
          <li class="fragment">No type safety</li>
          <li class="fragment">No error handling</li>
          <li class="fragment">Poor performance</li>
          <li class="fragment">...PHP doesn't have them</li>
        </ul>
        <aside class="notes">
          <ul>
            <li>Need to address the elephant in the room...</li>
          </ul>
        </aside>
      </section>
      <section data-background="assets/elephpants.jpg" data-background-size="contain" data-credit="Larry Garfield">
      </section>
    </section>
    <section>
      <section>
        <h2>What is in array?</h2>
        <ul>
          <li>ordered sequence</li>
          <li class="fragment">of values</li>
          <li class="fragment">of the same type</li>
          <li class="fragment">identified by their offset</li>
        </ul>
      </section>
      <section>
        <!-- picture of linear array -->
      </section>
      <section>
        <h3>PHP has associative arrays</h3>
        <ul>
          <li>Arbitrary key-value index</li>
          <li class="fragment">"Dictionary"/"Map"</li>
          <li class="fragment">Numeric arrays via a hack</li>
          <li class="fragment">No type guaratees (on value or key)</li>
        </ul>
      </section>
      <section>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $a[] = 'A';
          $a[] = 'B';
          print_r($a);
          unset($a[1]);
          $a[] = 'C';
          print_r($a);
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape>
          Array
          (
              [0] => A
              [1] => B
          )
          Array
          (
              [0] => A
              [2] => C
          )
        </code></pre>
        <aside class="notes">
          <ul>
            <li>[] op means "make up int key based on counter"</li>
          </ul>
        </aside>
      </section>
      <section>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          for ($i = 0; $i < count($a); ++$i) {
            print $a[$i];
          }
        </code></pre>
        <p class="fragment">Notice: Undefined offset: 1 in /in/fQ0UB on line 13</p>
        <aside class="notes">
          <ul>
            <li>for loop is inherently unreliable</li>
            <li>$a[$i] will break; AI is threat.</li>
          </ul>
        </aside>
      </section>
      <section data-transition="slide-in none-out">
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          protected function expandArguments(&$query, &$args) {
              foreach ($args as $key => $data) {
                // Handle expansion of arrays.
                $key_name = str_replace('[]', '__', $key);
                $new_keys = [];
                foreach ($data as $i => $value) {
                  $new_keys[$key_name . $i] = $value;
                }

                // Update the query with the new placeholders.
                $query = str_replace($key, implode(', ', array_keys($new_keys)), $query);

                // Update the args array with the new placeholders.
                unset($args[$key]);
                $args += $new_keys;
              }
          }
        </code></pre>
      </section>
      <section data-transition="none">
        <pre><code class="php" data-trim data-noescape data-line-numbers="6,7,11">
          protected function expandArguments(&$query, &$args) {
              foreach ($args as $key => $data) {
                // Handle expansion of arrays.
                $key_name = str_replace('[]', '__', $key);
                $new_keys = [];
                foreach ($data as $i => $value) {
                  $new_keys[$key_name . $i] = $value;
                }

                // Update the query with the new placeholders.
                $query = str_replace($key, implode(', ', array_keys($new_keys)), $query);

                // Update the args array with the new placeholders.
                unset($args[$key]);
                $args += $new_keys;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>What happens if $data is string keys?</li>
          </ul>
        </aside>
      </section>
      <section data-transition="none-in slide-out">
        <pre><code class="php" data-trim data-noescape data-line-numbers="6">
          protected function expandArguments(&$query, &$args) {
              foreach ($args as $key => $data) {
                // Handle expansion of arrays.
                $key_name = str_replace('[]', '__', $key);
                $new_keys = [];
                foreach (array_values($data) as $i => $value) {
                  $new_keys[$key_name . $i] = $value;
                }

                // Update the query with the new placeholders.
                $query = str_replace($key, implode(', ', array_keys($new_keys)), $query);

                // Update the args array with the new placeholders.
                unset($args[$key]);
                $args += $new_keys;
              }
          }
        </code></pre>
      </section>
      <section>
        <h2>Drupageddon, 2014</h2>
        <img src="assets/druplicon.svg" width="500px" alt="Drupal" />
        <aside class="notes">
          <ul>
            <li>Worst security hole in Drupal history</li>
            <li>Caused by lack of type safety in arrays</li>
            <li>Also hole in Form API to be able to inject associative array</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="oversize">PHP uses arrays in place of purpose-built data structures.</p>
        <p class="oversize fragment">That is almost never the right answer.</p>
      </section>
    </section>
    <section>
      <p class="oversize">So what's better?</p>
      <p class="oversize fragment">Purpose-built data structures.</p>
    </section>
    <section>
      <section>
        <h2>Lists/Sequences</h2>
        <aside class="notes">
          <ul>
            <li>OK for trivial cases, but break down quickly.</li>
            <li>Just saw two problems.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3><code>\ArrayObject</code></h3>
        <h3 class="fragment"><code>class TypedArray extends \ArrayObject</code></h3>
        <aside class="notes">
          <ul>
            <li>"data structure" in PHP means class/object</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>A type-specific "array"</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class TypedArray extends \ArrayObject {
              protected $type;

              public static function forType(string $type) : self {
                  $ret = new static();
                  $ret->type = $type;
                  return $ret;
              }

              protected function __construct(...$args) {
                  parent::__construct(...$args);
              }

              public function offsetSet($index, $newval) {
                  if (! $newval instanceof $this->type) {
                      throw new \TypeError(
                        sprintf('Only values of type %s are supported', $this->type)
                      );
                  }
                  parent::offsetSet($index, $newval);
              }
          }
        </code></pre>
      </section>
      <section>
        <h3>A type-specific "array"</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $a = TypedArray::forType(Point::class);

          $a[0] = new Point(2, 4);
          $a[1] = new Point(6, 9);
          $a['foobar'] = new Point(5, 2);

          foreach ($a as $point) { ... }
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape data-line-numbers>
          // Throws \TypeError.
          $a['bad'] = new Carrot();
          $a['also_bad'] = 'a point';
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Certain in foreach() of what you have</li>
            <li>What if we want to ensure sequential list?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Force a sequence through the API</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class TypedSequence implements \IteratorAggregate, \Countable {
              protected string $type;
              protected array $values = [];

              public static function forType(string $type) : self {...}
              protected function __construct() {}

              public function getIterator() {
                  return new ArrayIterator($this->values);
              }

              public function count() : int {
                  return count($this->values);
              }

              public function add($newval) : self {
                  if (! $newval instanceof $this->type) {
                      throw new \TypeError(...);
                  }
                  $this->values = $newval;
                  return $this;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Countable: count()</li>
            <li>IteratorAggregate: return thing to be iterated</li>
            <li>Uses array internally: OK!</li>
            <li>Can also add has(), other methods.</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="challenge-q"><q>But arrays pass by value, objects by reference!</q></p>
        <p class="fragment challenge-a"><q>No, objects pass by value. You've been lied to.</q></p>
        <p class="fragment challenge-q"><q>But they're modifiable!</q></p>
        <p class="fragment challenge-a"><q>Their handle passes by value, not the object.</q></p>
        <p class="fragment challenge-q"><q>OMGWTFBBQ?</q></p>
        <p class="fragment challenge-a"><q>Sigh.</q></p>
        <aside class="notes">
          <ul>
            <li>Objects pass in a way that makes them modifiable</li>
            <li>Bad.  But we can fix that ourselves.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Can't touch this</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class ImmutableTypedSequence implements IteratorAggregate, Countable {
              // Same as TypedSequence, but...

              public function add($newval) : self {
                  if (!$newval instanceof $this->type) { throw new \TypeError(...);}

                  $new = clone($this);
                  $values = array_merge($this->values, [$newval]);
                  $new->values = $values;
                  return $new;
              }

              public function remove($val) : self {
                  if ($key = array_search($val, $this->values, true)) {
                      $values = $this->values;
                      unset($values[$key]);
                      $new = clone($this);
                      $new->values = array_values($values);
                      return $new;
                  }
                  return $this;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>array_values() to reset index.</li>
            <li>Add whatever lookup methods you want/need.</li>
            <li>Copy on write</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Type-specific</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class PointSequence implements IteratorAggregate, Countable {
              // Same as before, but...

              public function add(Point $newval) : self {
                  $new = clone($this);
                  $values = array_merge($this->values, [$newval]);
                  $new->values = $values;
                  return $new;
              }

              public function remove(Point $val) : self {
                  if ($key = array_search($val, $this->values, true)) {
                      $values = $this->values;
                      unset($values[$key]);
                      $new = clone($this);
                      $new->values = array_values($values);
                      return $new;
                  }
                  return $this;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Type hints instead of manual checks</li>
            <li>Easy enough to make for any type, including primitives</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Uniqueness ("Set")</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Set extends ImmutableTypedSequence {

              public function has($val) : bool {
                  return array_search($val, $this->values, true) !== false;
              }

              public function add($newval) : self {
                  return $this->has($newval) ? $this : parent::add($newval);
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Guaranteed unique value</li>
            <li>Probably shouldn't use inheritance, but fits on a slide.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Ordering</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class OrderedSet extends Set {
              protected $compare;

              public static function forType(string $type, callable $compare = null) : self {
                  $ret = new static();
                  $ret->type = $type;
                  $ret->compare = $compare;
                  return $ret;
              }

              public function getIterator() {
                  if ($this->compare) {
                      usort($this->values, $this->compare);
                  }
                  return new ArrayIterator($this->values);
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Provide sorting comparison function</li>
          </ul>
        </aside>
      </section>
      <section>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $compare = fn(Point $a, Point $b): int => [$a->x, $a->y] <=> [$b->x, $b->y];

          $s = OrderedSet::forType(Point::class, $compare)
              ->add(new Point(3, 4))
              ->add(new Point(2, 5))
              ->add(new Point(2, 3));

          foreach ($s as $point) {
              var_dump($point);
          }
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape data-line-numbers>
          Point Object
          (
              [x] => 2
              [y] => 3
          )
          Point Object
          (
              [x] => 2
              [y] => 5
          )
          Point Object
          (
              [x] => 3
              [y] => 4
          )
        </code></pre>
        <aside class="notes">
          <ul>
            <li>At this point should just do dedicated set for type</li>
            <li>It's quite easy and fast</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>What have we gained?</h3>
        <ul>
          <li class="fragment">Type-safe lists</li>
          <li class="fragment">Sequence-guaranteed lists</li>
          <li class="fragment">Immutability guarantee</li>
          <li class="fragment">Self-documenting API</li>
          <li class="fragment">Encapsulation of functionality</li>
        </ul>
        <aside class="notes">
          <ul>
            <li>Every example class took <10, mostly < 5 min</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Passable lists</h2>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <p class="oversize">Can't type hint on <code>array</code> anymore</p>
          <h2 class="oversize fragment">:-(</h2>
        </div>
        <aside class="notes">
          <ul>
            <li>Two use cases to consider</li>
          </ul>
        </aside>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <h3>Do you care about the type of the objects?</h3>
          <p class="fragment oversize"><code>FooList implements \Traversable</code></p>
        </div>
        <aside class="notes">
          <ul>
            <li>Make it a real typed collection</li>
            <li>It's now a domain object in your API</li>
          </ul>
        </aside>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <h3>Do you just want to be able to <code>foreach()</code></h3>
          <p class="fragment oversize"><code>iterable</code></p>
        </div>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <p class=""><code>iterable :: array|\Traversable</code></p>
          <p class=" fragment"><code>\Traversable :: \Iterator|\IteratorAggregate</code></p>
          <p class=" fragment"><code>\Generator implements \Iterator</code></p>
        </div>
      </section>
      <section>
        <h3>Generators</h3>
        <ul>
          <li class="fragment">Lazy stream of values</li>
          <li class="fragment">Lazy value creation</li>
          <li class="fragment">Structure flattening</li>
          <li class="fragment">Simpler code</li>
        </ul>
      </section>
      <section>
        <h3>A PSR-14 example</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
        interface ListenerProviderInterface {
            /**
             * @param object $event
             *   An event for which to return the relevant listeners.
             * @return iterable[callable]
             *   An iterable (array, iterator, or generator) of callables.  Each
             *   callable MUST be type-compatible with $event.
             */
            public function getListenersForEvent(object $event) : iterable;
        }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Why iterable? All we'll do is iterate.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>A PSR-14 example</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Dispatcher implements DispatcherInterface {
            // ...

            public function dispatch(object $event) {

              foreach ($this->provider->getListenersForEvent($event) as $listener) {
                if ($event instanceof StoppableEventInterface
                    && $event->isPropagationStopped()) {
                  break;
                }
                $listener($event);
              }

              return $event;
            }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>All we care about is foreachable() set of callables</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Tukio (PSR-14 reference implementation)</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class CallbackProvider implements ListenerProviderInterface {
              // ...

              public function getListenersForEvent(object $event): iterable {
                  if (!$event instanceof CallbackEventInterface) {
                      return [];
                  }
                  $subject = $event->getSubject();

                  foreach ($this->callbacks as $type => $callbacks) {
                      if ($event instanceof $type) {
                          foreach ($callbacks as $callback) {
                              if (method_exists($subject, $callback)) {
                                  yield [$subject, $callback];
                              }
                          }
                      }
                  }
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Arbitrarily complex logic, easily flattened by a generator</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Trivial to concatenate</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class AggregateProvider implements ListenerProviderInterface {
              /** @var array */
              protected $providers = [];

              public function getListenersForEvent(object $event): iterable {
                  /** @var ListenerProviderInterface $provider */
                  foreach ($this->providers as $provider) {
                      yield from $provider->getListenersForEvent($event);
                  }
              }
              // ...
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Don't know or care if nested providers are lazy</li>
          </ul>
        </aside>
      </section>
    </section>





    <section>
        <pre><code class="php" data-trim data-noescape data-line-numbers>

        </code></pre>
    </section>


    <!--
Arrays: All over PHP.
Array of problems (yes the puns will be that bad), better options.

Does PHP even have arrays?
ElePHPant in the room.  (ElePHPant pic, person in suit)

Array definition: ordered sequence of values identified by their offset, of the same type.
Pic of linear array.

PHP: Associative array; dictionary, map, etc.  Ordered key value map.
Numeric arrays are a hack.  (Examples of where they break down, inc Drupageddon.)
No type consistency.

PHP uses arrays in place of purpose built data structures; PBDS are better almost always.

See examples.

Lists/sequences
* OK for trivial cases, but want more guarantees most of the time.
* ArrayObject
* TypedArray - Forces a type
* TypedIndexedArray - Forces indexed array only.
* Immutability - ImmutableTypedIndexArray
* Uniqueness - Sets

Iteration
* iterables
* PSR-14, or maybe better example?
* Genertors FTW
* Array operations? Easy to replicate

Lookup tables
* Maps - Lookup object

Typed data
* Assoc array as anon struct.
* Value objects
* Immutability again
* Drive design: $config params suck.
* Refactor $config
* Multiple returns, too

Performance
* Show benchmarks
* Show tweet
* Boom!

Wither arrays?
* Impl detail
* Pass array literal to iterable.
* callable tuple.
* Compiled code.

    -->


    <section id="final">
      <h2>Larry Garfield</h2>
      <h2><a href="http://twitter.com/Crell">@Crell</a></h2>
      <p>Director of Developer Experience <a href="http://www.platform.sh/">Platform.sh</a></p>
      <p>Idea to Cloud Hosting</p>
      <p>Stalk us at <a href="http://twitter.com/Platformsh">@PlatformSH</a></p>
    </section>

</div>

<script src="js/reveal.js"></script>

<script>
	// More info about config & dependencies:
	// - https://github.com/hakimel/reveal.js#configuration
	// - https://github.com/hakimel/reveal.js#dependencies
	Reveal.initialize({
    hash: true,
    controlsTutorial: false,
		dependencies: [
			{ src: 'plugin/markdown/marked.js' },
			{ src: 'plugin/markdown/markdown.js' },
			{ src: 'plugin/notes/notes.js', async: true },
			{ src: 'plugin/highlight/highlight.js', async: true }
		]
	});
</script>

<!-- Custom Reveal extension scripts. -->
<script src="platform/classer.js"></script>
<script src="platform/countup.js"></script>
<script src="platform/usecase.js"></script>

</body>
</html>
