<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Never* Use Arrays</title>

	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/reveal.css" />
<!--	<link rel="stylesheet" href="css/theme/black.css">-->

  <link rel="stylesheet" href="platform/platformsh.css" />

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

  <style type="text/css">

    p.challenge-q {
      color: blue;
    }

    p.challenge-a {
      color: green;
    }
  </style>

</head>
<body class="skin-blue">
<div class="reveal">
  <footer>
    <img class="logo" src="platform/logos/platformsh-logo-black.svg" alt="Platform.sh" />
    <span class="name">@Crell</span>
  </footer>
	<div class="slides">
    <section class="title">
      <h1>Never* Use Arrays</h1>
    </section>

    <section id="presenter">
      <h2>Larry Garfield</h2>
      <h2><a href="https://twitter.com/Crell">@Crell</a></h2>
      <div class="layout-col vcentered">
        <img src="assets/larry-olaf-hug.jpg" alt="Larry implements Huggable" style="width: 350px; margin: 0" />
        <ul style="text-wrap: none">
          <li>Director of DX, <a href="http://www.platform.sh/">Platform.sh</a></li>
          <li style="margin-top: 1em;">PHP-FIG Core Committee</li>
          <li style="margin-top: 1em;"><code>implements Huggable</code></li>
        </ul>
      </div>
    </section>

    <section>
      <section>
        <p style="font-size: 4rem;">array(<img src="assets/php-logo.svg" style="height: 1em; text-align: center;" alt="PHP" data-credit="https://commons.wikimedia.org/wiki/File:PHP-logo.svg" />)</p>
        <aside class="notes">
          <ul>
            <li>PHP loves arrays</li>
            <li>The iconic PHP-ism</li>
            <li>Used everywhere</li>
            <li>Over 80 array manipulation functions</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="oversize">They come with an <code>array</code> of problems.</p>
        <div class="fragment"><img src="assets/picard-facepalm.jpg" class="meme" alt="The jokes will be that bad."></div>
        <aside class="notes">
          <ul>
            <li>Yes, the jokes will be that bad.</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="oversize">They come with an <code>array</code> of problems.</p>
        <ul>
          <li class="fragment">Inconsistent behavior</li>
          <li class="fragment">No type safety</li>
          <li class="fragment">No error handling</li>
          <li class="fragment">Poor performance</li>
          <li class="fragment">...PHP doesn't have them</li>
        </ul>
        <aside class="notes">
          <ul>
            <li>Type safety: Everything in the array is of a known same type</li>
            <li>Need to address the elephant in the room...</li>
          </ul>
        </aside>
      </section>
      <section data-background="assets/larry-elephpant.jpg" data-background-size="contain" data-credit="Concrete 5">
      </section>
    </section>
    <section>
      <section>
        <h2>What is in array?</h2>
        <ul>
          <li class="fragment">ordered sequence</li>
          <li class="fragment">of values</li>
          <li class="fragment">of the same type</li>
          <li class="fragment">identified by their offset</li>
        </ul>
      </section>
      <section>
        <h3>PHP has associative arrays</h3>
        <ul>
          <li class="fragment">Arbitrary key-value index</li>
          <li class="fragment">"Dictionary"/"Map"</li>
          <li class="fragment">Numeric arrays via a hack</li>
          <li class="fragment">No type guarantees (on value or key)</li>
        </ul>
      </section>
      <section>
        <h3>Arrays are a hack</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $a[] = 'A';
          $a[] = 'B';
          print_r($a);
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape>
          Array
          (
              [0] => A
              [1] => B
          )
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape>
          unset($a[1]);
          $a[] = 'C';
          print_r($a);
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape>
          Array
          (
              [0] => A
              [2] => C
          )
        </code></pre>
        <aside class="notes">
          <ul>
            <li>[] op means "make up int key based on counter"</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Arrays are a buggy hack</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          for ($i = 0; $i < count($a); ++$i) {
            print $a[$i];
          }
        </code></pre>
        <p class="fragment">Notice: Undefined offset: 1 in /in/fQ0UB on line 13</p>
        <aside class="notes">
          <ul>
            <li>for loop is inherently unreliable</li>
            <li>$a[$i] will break; AI is threat.</li>
          </ul>
        </aside>
      </section>
      <section data-transition="slide-in none-out">
        <h3>What's wrong with this picture?</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          protected function expandArguments(&$query, &$args) {
              foreach ($args as $key => $data) {
                // Handle expansion of arrays.
                $key_name = str_replace('[]', '__', $key);
                $new_keys = [];
                foreach ($data as $i => $value) {
                  $new_keys[$key_name . $i] = $value;
                }

                // Update the query with the new placeholders.
                $query = str_replace($key, implode(', ', array_keys($new_keys)), $query);

                // Update the args array with the new placeholders.
                unset($args[$key]);
                $args += $new_keys;
              }
          }
        </code></pre>
      </section>
      <section data-transition="none">
        <h3>Hey, look, an SQL injection!</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers="6,7,11">
          protected function expandArguments(&$query, &$args) {
              foreach ($args as $key => $data) {
                // Handle expansion of arrays.
                $key_name = str_replace('[]', '__', $key);
                $new_keys = [];
                foreach ($data as $i => $value) {
                  $new_keys[$key_name . $i] = $value;
                }

                // Update the query with the new placeholders.
                $query = str_replace($key, implode(', ', array_keys($new_keys)), $query);

                // Update the args array with the new placeholders.
                unset($args[$key]);
                $args += $new_keys;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>What happens if $data is string keys?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Drupageddon, 2014</h2>
        <img src="assets/druplicon.svg" width="500px" alt="Drupal" />
        <aside class="notes">
          <ul>
            <li>Worst security hole in Drupal history</li>
            <li>Caused by lack of type safety in arrays</li>
            <li>Also hole in Form API to be able to inject associative array</li>
          </ul>
        </aside>
      </section>
      <section data-transition="none-in slide-out">
        <h3>Stupid simple fix</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers="6">
          protected function expandArguments(&$query, &$args) {
              foreach ($args as $key => $data) {
                // Handle expansion of arrays.
                $key_name = str_replace('[]', '__', $key);
                $new_keys = [];
                foreach (array_values($data) as $i => $value) {
                  $new_keys[$key_name . $i] = $value;
                }

                // Update the query with the new placeholders.
                $query = str_replace($key, implode(', ', array_keys($new_keys)), $query);

                // Update the args array with the new placeholders.
                unset($args[$key]);
                $args += $new_keys;
              }
          }
        </code></pre>
      </section>
      <section>
        <p class="oversize">PHP uses arrays in place of purpose-built data structures.</p>
        <p class="oversize fragment">That is almost never the right answer.</p>
      </section>
    </section>
    <section>
      <p class="oversize">So what's better?</p>
      <p class="oversize fragment">Purpose-built data structures.</p>
    </section>
    <section>
      <section>
        <h2>Lists/Sequences</h2>
        <aside class="notes">
          <ul>
            <li>OK for trivial cases, but break down quickly.</li>
            <li>Just saw two problems.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3><code>\ArrayObject</code></h3>
        <h3 class="fragment"><code>class TypedArray extends \ArrayObject</code></h3>
        <aside class="notes">
          <ul>
            <li>"data structure" in PHP means class/object</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>A type-specific "array"</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class TypedArray extends \ArrayObject {
              protected $type;

              public static function forType(string $type) : self {
                  $ret = new static();
                  $ret->type = $type;
                  return $ret;
              }

              protected function __construct(...$args) {
                  parent::__construct(...$args);
              }

              public function offsetSet($index, $newval) {
                  if (! $newval instanceof $this->type) {
                      throw new \TypeError(
                        sprintf('Only values of type %s are supported', $this->type)
                      );
                  }
                  parent::offsetSet($index, $newval);
              }
          }
        </code></pre>
      </section>
      <section>
        <h3>A type-specific "array"</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $a = TypedArray::forType(Point::class);

          $a[0] = new Point(2, 4);
          $a[1] = new Point(6, 9);
          $a['foobar'] = new Point(5, 2);

          foreach ($a as $point) { ... }
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape data-line-numbers>
          // Throws \TypeError.
          $a['bad'] = new Carrot();
          $a['also_bad'] = 'a point';
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Certain in foreach() of what you have</li>
            <li>What if we want to ensure sequential list?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Force a sequence through the API</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class TypedSequence implements \IteratorAggregate, \Countable {
              protected string $type;
              protected array $values = [];

              public static function forType(string $type) : self {...}
              protected function __construct() {}

              public function getIterator() {
                  return new ArrayIterator($this->values);
              }

              public function count() : int {
                  return count($this->values);
              }

              public function add($newval) : self {
                  if (! $newval instanceof $this->type) {
                      throw new \TypeError(...);
                  }
                  $this->values[] = $newval;
                  return $this;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Countable: count()</li>
            <li>IteratorAggregate: return thing to be iterated</li>
            <li>Uses array internally: OK!</li>
            <li>Can also add has(), other methods.</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="challenge-q"><q>But arrays pass by value, objects by reference!</q></p>
        <p class="fragment challenge-a"><q>No, objects pass by value. You've been lied to.</q></p>
        <p class="fragment challenge-q"><q>But they're modifiable!</q></p>
        <p class="fragment challenge-a"><q>Their handle passes by value, not the object.</q></p>
        <p class="fragment challenge-q"><q>OMGWTFBBQ?</q></p>
        <p class="fragment challenge-a"><q>Sigh.</q></p>
        <aside class="notes">
          <ul>
            <li>Handle: Object in mem sep from the value that refers to it</li>
            <li>Objects pass in a way that makes them modifiable</li>
            <li>Bad.  But we can fix that ourselves.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Can't touch <code>$this</code></h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class ImmutableTypedSequence implements IteratorAggregate, Countable {
              // Same as TypedSequence, but...

              public function add($newval) : self {
                  if (!$newval instanceof $this->type) { throw new \TypeError(...);}

                  $new = clone($this);
                  $values = array_merge($this->values, [$newval]);
                  $new->values = $values;
                  return $new;
              }

              public function remove($val) : self {
                  if ($key = array_search($val, $this->values, true)) {
                      $values = $this->values;
                      unset($values[$key]);
                      $new = clone($this);
                      $new->values = array_values($values);
                      return $new;
                  }
                  return $this;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>array_values() to reset index.</li>
            <li>Add whatever lookup methods you want/need.</li>
            <li>Copy on write</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Type-specific</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class PointSequence implements IteratorAggregate, Countable {
              // Same as before, but...

              public function add(Point $newval) : self {
                  $new = clone($this);
                  $values = array_merge($this->values, [$newval]);
                  $new->values = $values;
                  return $new;
              }

              public function remove(Point $val) : self {
                  if ($key = array_search($val, $this->values, true)) {
                      $values = $this->values;
                      unset($values[$key]);
                      $new = clone($this);
                      $new->values = array_values($values);
                      return $new;
                  }
                  return $this;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Type hints instead of manual checks</li>
            <li>Easy enough to make for any type, including primitives</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Uniqueness ("Set")</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Set extends ImmutableTypedSequence {

              public function has($val) : bool {
                  return array_search($val, $this->values, true) !== false;
              }

              public function add($newval) : self {
                  return $this->has($newval) ? $this : parent::add($newval);
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Guaranteed unique value</li>
            <li>Probably shouldn't use inheritance, but fits on a slide.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Ordering</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class OrderedSet extends Set {
              protected $compare;

              public static function forType(string $type, callable $compare = null) : self {
                  $ret = new static();
                  $ret->type = $type;
                  $ret->compare = $compare;
                  return $ret;
              }

              public function getIterator() {
                  if ($this->compare) {
                      usort($this->values, $this->compare);
                  }
                  return new ArrayIterator($this->values);
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Provide sorting comparison function</li>
          </ul>
        </aside>
      </section>
      <section>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $compare = fn(Point $a, Point $b): int => [$a->x, $a->y] <=> [$b->x, $b->y];

          $s = OrderedSet::forType(Point::class, $compare)
              ->add(new Point(3, 4))
              ->add(new Point(2, 5))
              ->add(new Point(2, 3));

          foreach ($s as $point) {
              var_dump($point);
          }
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape data-line-numbers>
          Point Object
          (
              [x] => 2
              [y] => 3
          )
          Point Object
          (
              [x] => 2
              [y] => 5
          )
          Point Object
          (
              [x] => 3
              [y] => 4
          )
        </code></pre>
        <aside class="notes">
          <ul>
            <li>At this point should just do dedicated set for type</li>
            <li>It's quite easy and fast</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>What have we gained?</h3>
        <ul>
          <li class="fragment">Type-safe lists</li>
          <li class="fragment">Sequence-guaranteed lists</li>
          <li class="fragment">Immutability guarantee</li>
          <li class="fragment">Self-documenting API</li>
          <li class="fragment">Encapsulation of functionality</li>
        </ul>
        <aside class="notes">
          <ul>
            <li>Every example class took <10, mostly < 5 min</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Passable lists</h2>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <p class="oversize">Can't type hint on <code>array</code> anymore</p>
          <h2 class="oversize fragment">:-(</h2>
        </div>
        <aside class="notes">
          <ul>
            <li>Two use cases to consider</li>
          </ul>
        </aside>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <h3>Do you care about the type of the objects?</h3>
          <p class="fragment oversize"><code>ProductList implements \Traversable</code></p>
        </div>
        <aside class="notes">
          <ul>
            <li>Make it a real typed collection</li>
            <li>It's now a domain object in your API</li>
          </ul>
        </aside>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <h3>Do you just want to be able to <code>foreach()</code></h3>
          <p class="fragment oversize"><code>iterable</code></p>
        </div>
      </section>
      <section>
        <div class="layout-stacked" style="height: 650px">
          <p class=""><code>iterable :: array|\Traversable</code></p>
          <p class=" fragment"><code>\Traversable :: \Iterator|\IteratorAggregate</code></p>
          <p class=" fragment"><code>\Generator implements \Iterator</code></p>
        </div>
      </section>
      <section>
        <h3>Generators</h3>
        <ul>
          <li class="fragment">Lazy stream of values</li>
          <li class="fragment">Lazy value creation</li>
          <li class="fragment">Structure flattening</li>
          <li class="fragment">Simpler code</li>
        </ul>
      </section>
      <section>
        <h3>A PSR-14 example</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
        interface ListenerProviderInterface {
            /**
             * @param object $event
             *   An event for which to return the relevant listeners.
             * @return iterable[callable]
             *   An iterable (array, iterator, or generator) of callables.  Each
             *   callable MUST be type-compatible with $event.
             */
            public function getListenersForEvent(object $event) : iterable;
        }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Why iterable? All we'll do is iterate.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>A PSR-14 example</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Dispatcher implements DispatcherInterface {
            // ...

            public function dispatch(object $event) {

              foreach ($this->provider->getListenersForEvent($event) as $listener) {
                if ($event instanceof StoppableEventInterface
                    && $event->isPropagationStopped()) {
                  break;
                }
                $listener($event);
              }

              return $event;
            }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>All we care about is foreachable() set of callables</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3><a href="https://github.com/Crell/Tukio">Tukio</a> (PSR-14 reference implementation)</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class CallbackProvider implements ListenerProviderInterface {
              // ...

              public function getListenersForEvent(object $event): iterable {
                  if (!$event instanceof CallbackEventInterface) {
                      return [];
                  }
                  $subject = $event->getSubject();

                  foreach ($this->callbacks as $type => $callbacks) {
                      if ($event instanceof $type) {
                          foreach ($callbacks as $callback) {
                              if (method_exists($subject, $callback)) {
                                  yield [$subject, $callback];
                              }
                          }
                      }
                  }
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Arbitrarily complex logic, easily flattened by a generator</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Trivial to concatenate</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class AggregateProvider implements ListenerProviderInterface {
              /** @var array */
              protected $providers = [];

              public function getListenersForEvent(object $event): iterable {
                  /** @var ListenerProviderInterface $provider */
                  foreach ($this->providers as $provider) {
                      yield from $provider->getListenersForEvent($event);
                  }
              }
              // ...
          }
        </code></pre>
        <p>From <a href="https://github.com/php-fig/event-dispatcher-util">fig/event-dispatcher-util</a></p>
        <aside class="notes">
          <ul>
            <li>Don't know or care if nested providers are lazy</li>
          </ul>
        </aside>
      </section>
      <section>
        <div class="layout-stacked" style="height: 600px">
          <h3><q>But what about <code>array_*</code> functions?</q></h3>
          <p class="oversize fragment"><q>What about them?</q></p>
        </div>
      </section>
      <section>
        <h3><code>array_*</code> functions</h3>
        <ul>
          <li class="fragment">Rarely used</li>
          <li class="fragment">Internal implementation detail</li>
          <li class="fragment">Easy to reimplement</li>
        </ul>
      </section>
      <section>
        <h3>The most common</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          function iterable_map(iterable $list, callable $operation) : iterable {
            foreach ($list as $k => $v) {
              yield $operation($k, $v);
            }
          }

          function iterable_filter(iterable $list, callable $filter) : iterable {
            foreach ($list as $k => $v) {
              if ($filter($v)) {
                yield $k => $v;
              }
            }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Rare that I need any others</li>
            <li>Not unheard of, but rare</li>
            <li>Most others can be reimplemented to iterables, too.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Collection objects</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Collection implements \IteratorAggregate {
              protected $valuesGenerator;

              protected function __construct(){}

              public static function fromIterable(iterable $values = null) {
                  $values ??= [];
                  return static::fromGenerator(function () use ($values) {
                      yield from $values;
                  });
              }

              public static function fromGenerator(callable $callback) : self {
                  $new = new static();
                  $new->valuesGenerator = $callback;
                  return $new;
              }

              public function getIterator() : iterable {
                  return ($this->valuesGenerator)();
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Completely generator-based collection</li>
            <li>Values converted to generator</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Collection objects</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Collection implements \IteratorAggregate {
              // ...
              public function append(iterable ...$collections) : self {
                  return static::fromGenerator(function() use ($collections) {
                      yield from ($this->valuesGenerator)();
                      foreach ($collections as $col) {
                          yield from $col;
                      }
                  });
              }

              public function add(...$items) : self {
                  return $this->append($items);
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Adding values is just concatenating lists/generators</li>
            <li>add() is append().  One is a special case of many.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Collection objects</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Collection implements \IteratorAggregate {
              // ...
              public function map(callable $fn) : self {
                  return static::fromGenerator(function () use ($fn) {
                      foreach (($this->valuesGenerator)() as $key => $val) {
                          yield $key => $fn($val);
                      }
                  });
              }

              public function toArray() : array {
                  return iterator_to_array((function() {
                      foreach ($this as $value) {
                          yield $value;
                      }
                  })());
              }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>map() gives new collection that will filter when iterated</li>
            <li>toArray() can't just iterator_to_array() as keys will collide.</li>
            <li>This streams values out individually, ignores keys.</li>
            <li>filter() left as exercise for the reader.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Collection objects</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $c = Collection::fromIterable([1, 2, 3]);

          $c = $c->add(4, 5, 6);
          $c = $c->map(fn($v) => $v * 10);

          print_r($c->toArray());
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape data-line-numbers>
          Array
          (
              [0] => 10
              [1] => 20
              [2] => 30
              [3] => 40
              [4] => 50
              [5] => 60
          )
        </code></pre>
        <p class="fragment">Can you add map/filter to OrderedSet?</p>
        <aside class="notes">
          <ul>
            <li><60 lines, including whitespace</li>
            <li>More robust libs exist, but easy to implement as-needed</li>
            <li>Make your own ad-hoc on collection classes</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <h3><q>But what about associative arrays?</q></h3>
      <aside class="notes">
        <ul>
          <li>Two kinds: Lookup tables, anonymous structs</li>
        </ul>
      </aside>
    </section>
    <section>
      <section>
        <h2>Lookup tables</h2>
        <ul>
          <li class="fragment">Map from arbitrary value to arbitrary value</li>
          <li class="fragment">Keys are int or string only</li>
          <li class="fragment">Good for user/config-supplied keys</li>
        </ul>
      </section>
      <section>
        <h3>A common pattern</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $builders = [];
          foreach (getRegisteredBuilderPlugins() as $builder) {
              $builders[$builder->format()] = $builder;
          }
          // ...

          $output = $lookup[$request->getHeaderLine('Accept')]->buildOutput($stuff);
        </code></pre>
        <ul class="fragment" style="margin-top: 1em;">
          <li>Error handling?</li>
          <li>Missing keys?</li>
          <li>Type safety?</li>
        </ul>
      </section>
      <section>
        <h3>Build your own lookup utility</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Lookup implements ArrayAccess {
              protected $type;
              protected $values;
              protected $default;

              public static function forType(string $type, $default = null) : self {
                  // Like we saw before, but also save $default.
              }

              public function offsetSet($offset, $value) {
                  if (! is_string($offset)) { throw new \TypeError(...); }
                  if (! $value instanceof $this->type) { throw new \TypeError(...);}

                  $this->values[$offset] = $value;
              }

              public function offsetGet($offset) {
                  return $this->values[$offset] ?? $this->default;
              }

              public function offsetExists($offset) { ... }
              public function offsetUnset($offset) { ... }
          }
        </code></pre>
      </section>
      <section>
        <h3>Error handling is internalized</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $builders = Lookup::forType(OutputBuilder::class, new DefaultBuilder());

          foreach (getRegisteredBuilderPlugins() as $builder) {
              $builders[$builder->format()] = $builder;
          }
          // ...

          $output = $lookup[$request->getHeaderLine('Accept')]->buildOutput($stuff);
        </code></pre>
      </section>
      <section>
        <h3>Or without <code>ArrayAccess</code></h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class Lookup {
              protected $type;
              protected $values;

              public static function forType(string $type) : self {
                  // As before.
              }

              public function add(string $key, $value) {
                  if (! $value instanceof $this->type) { throw new \TypeError(...);}

                  $this->values[$key] = $value;
              }

              public function lookup(string $key, $default = null) {
                  return $this->values[$offset] ?? $default;
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>ArrayAccess is slower than method call</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Or a purpose-built service</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class BuilderMap {
              protected $defaultFmt;
              protected $provider;
              protected $builders = [];

              public function __construct(BuilderProvider $p, $defaultFmt = '') {...}

              protected function buildLookup() {
                  foreach ($this->provider->getRegisteredBuilderPlugins() as $b) {
                      $this->builders[$b->format()] = $b;
                  }
              }

              public function lookup(string $key) {
                  if (!$this->builders) $this->buildLookup();
                  return $this->values[$key] ?? $this->values[$this->defaultFmt];
              }
          }
        </code></pre>
        <pre class="fragment"><code class="php" data-trim data-noescape data-line-numbers>
          $builder = $builders->lookup($req->getHeaderLine('Accept'));
          $output = $builder->buildOutput($stuff);
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Configure this in your container</li>
            <li>Type checked throughout, so can't go wrong.</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Anonymous structs</h2>
        <aside class="notes">
          <ul>
            <li>When the keys are known and fixed at dev time</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Anonymous structs</h2>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          $order = [
              'id' => 345,
              'total' => 100.45,
              'skus' => [ 123, '5B3', '987'],
              'canceled' => false,
              'usr' => 8,
          ];
        </code></pre>
        <ul style="margin-top: 1em;">
          <li class="fragment">Is canceled spelled right?</li>
          <li class="fragment">Is usr correct or a typo?</li>
          <li class="fragment">Is user an ID or User object?</li>
          <li class="fragment">Are skus numeric or strings?</li>
          <li class="fragment">Can skus be a single value?</li>
          <li class="fragment">Are there other properties?</li>
          <li class="fragment">What currency is total in?</li>
        </ul>
      </section>
      <section>
        <h3>Named structs</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
        class Order {
            public string $id;
            public Money $total;
            public bool $cancelled = false;
            public User $user;
            public array $skus = [];
        }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Oh, ID is a string, not an integer.</li>
            <li>Oh, user is an object. We were wrong before.</li>
            <li>Oh, money is a proper value object, too.</li>
            <li>UK spelling of "cancelled".</li>
            <li>Not 100% better, but 80%.</li>
            <li>Could use a list object for $skus.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3><code>$options</code> is a code smell</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          function formatProduct(Product $product, array $options) : string {
            // ...
          }
        </code></pre>
        <ul style="margin-top: 1em;">
          <li class="fragment">What are the values for <code>$options</code>?</li>
          <li class="fragment">Which are required</li>
          <li class="fragment">How are they spelled</li>
          <li class="fragment">What are their legal types? How strict?</li>
        </ul>
        <p class="fragment oversize">¯\_(ツ)_/¯</p>
      </section>
      <section>
        <h3>So, docs?</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          /**
           * Formats a product.
           *
           * @param Product $product
           * @param array $options
           *   - label: The label to apply to the product.
           *   - bgcolor: A color code for the background.
           *   - bgcolor: A color code for the background.
           *   - color: A foreground color.
           *   - font-size: The size in points.
           *   - layout: The template to use.
           *
           * @return string
           */
          function formatProduct(Product $product, array $options) : string { ... }
        </code></pre>
        <p class="fragment oversize" style="margin-top: 1em;"><q>But good code is self documenting!</q></p>
      </section>
      <section>
        <h3>Objects are self-documenting</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class FormatterOptions {
              public string $label = 'Your product';
              public string $bgcolor = '#FFF';
              public string $color = '#000';
              public int $fontSize = 14;
              public string $layout;
          }

          function formatProduct(Product $p, FormatterOptions $options) : string {...}
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Know the properties</li>
            <li>Know the types</li>
            <li>Know defaults</li>
            <li>layout is required, others optional</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Objects have methods</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
        class FormatterOptions {
            public string $label = 'Your product';
            public string $bgcolor = '#FFF';
            public string $color = '#000';
            public int $fontSize = 14;
            public string $layout;

            public static function forLayout(string $layout) { ... }

            public function darkMode(bool $dark) : self {
                $this->bgcolor = $dark ? '#000' : '#FFF';
                $this->color  = $dark ? '#FFF' : '#000';
                return $this;
            }
        }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Bake in more robust functionality</li>
            <li>Robust domain model language</li>
            <li>Should really turn it around at that point.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Turn it around</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
        class ProductFormatter {
            // ...

            public function __construct(string $layout) {
              $this->layout = $layout;
            }

            public function darkMode(bool $dark) : self { ... }

            public function setColors(string $color, string $bgcolor) : self {
                $this->color = $color;
                $this->bgcolor = $bgcolor;
                return $this;
            }

            public function setFontInPoints(int $size) : self {
                $this->fontSize = $size;
                return $this;
            }

            public function format(Product $product) : string { ... }
        }
        </code></pre>
      </section>
      <section>
        <h3>Easy to use</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
        $formatter = new ProductFormatter('standard');

        $formatter->darkMode(true)->format($product);
        </code></pre>
        <div class="fragment" style="margin-top: 5em;">
          <h3>If has dependencies</h3>
          <pre><code class="php" data-trim data-noescape data-line-numbers>
        $formatter = $themeSystem->getFormatter('standard');

        $formatter->darkMode(true)->format($product);
        </code></pre>
        </div>
        <aside class="notes">
          <ul>
            <li>Build a do-er object, then use it.</li>
            <li>Could spawn from another service if need dependencies</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="oversize"><q>But aren't public properties eeeevil?</q></p>
        <ul>
          <li class="fragment">Private object => Public properties</li>
          <li class="fragment">Public API => protected properties with meaningful methods</li>
        </ul>
      </section>
    </section>
    <section>
      <section>
        <h2><q>But aren't objects big and slow</q></h2>
        <aside class="notes">
          <ul>
            <li>Old urban legend in PHP</li>
            <li>Maybe true in PHP 4?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Benchmarks, yo</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          const TEST_SIZE = 1000000;

          $list = [];
          $start = $stop = 0;
          $start = microtime(true);

          for ($i = 0; $i < TEST_SIZE; ++$i) {
            $list[$i] = [
              'a' => random_int(1, 500),
              'b' => base64_encode(random_bytes(16)),
            ];
          }

          ksort($list);

          usort($list, function($first, $second) {
            return [$first['a'], $first['b']] <=> [$second['a'], $second['b']];
          });

          $stop = microtime(true);
          $memory = memory_get_peak_usage();
          printf("Runtime: %s\nMemory: %s\n", $stop - $start, $memory);
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Same thing for stdClass, public props, private props with methods, anon class</li>
            <li>Multiple runs, averaged, etc.</li>
            <li>Goal is to access values a zillion times</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Results</h3>
        <table>
          <thead>
            <tr><th scope="col">Technique</th> <th scope="col">Runtime (s)</th> <th scope="col">Memory (bytes)</th></tr>
          </thead>
          <tbody>
            <tr class="fragment"> <th scope="row">Associative array</th> <td>9.4311 (n/a)</td> <td>541,450,384 (n/a)</td></tr>
            <tr class="fragment"> <th scope="row">stdClass</th> <td>11.2173 (+18.94%)</td> <td>589,831,120 (+8.94%)</td></tr>
            <tr class="fragment"> <th scope="row">Public properties</th> <td>8.2172 (-12.87%)</td> <td>253,831,584 (-53.12%)</td></tr>
            <tr class="fragment"> <th scope="row">Private properties</th> <td>11.0881 (+17.57%)</td> <td>253,833,000 (-53.12%)</td></tr>
            <tr class="fragment"> <th scope="row">Anonymous class</th> <td>8.1095 (-14.07%)</td> <td>253,832,368 (-53.12%)</td></tr>
          </tbody>
        </table>
        <p class="fragment"><img src="assets/mind-blown.gif" alt="Mind blown" width="400px" style="margin-top: 1em" /></p>
      </section>
      <section>
        <div style="display: flex; align-items: center; justify-content: center;">
          <blockquote class="twitter-tweet" data-lang="en" data-dnt="true">
            <p lang="en" dir="ltr">Replaced all object-like arrays with classes where they are used thousands of times.<br><br>Memory usage reduced by 58% (from 12Gb to 5Gb).<br><br>Please, read this article by <a href="https://twitter.com/Crell?ref_src=twsrc%5Etfw">@Crell</a>
              <a href="https://t.co/cHb3agX18R">https://t.co/cHb3agX18R</a> to understand why you have to prefer classes. <a href="https://t.co/ipuqmdpnWB">pic.twitter.com/ipuqmdpnWB</a></p>&mdash; Maks Rafalko (@maks_rafalko) <a href="https://twitter.com/maks_rafalko/status/1141822788124196867?ref_src=twsrc%5Etfw">June 20, 2019</a>
          </blockquote>
          <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
        </div>
        <p style="margin-top: 1em;">Source: <a href="https://steemit.com/php/@crell/php-use-associative-arrays-basically-never">"Use associative arrays basically never"</a></p>
      </section>
    </section>
    <section>
      <section>
        <p class="oversize"><q>So can you <em>ever</em> use an array?</q></p>
        <ul>
          <li class="fragment">Internal implementation detail</li>
          <li class="fragment">Array literal for iterable</li>
          <li class="fragment">Callables (<code>[$obj, 'method']</code>)</li>
          <li class="fragment">Generated code</li>
        </ul>
      </section>
      <section>
        <h3>This is actually more efficient (sometimes)</h3>
        <pre><code class="php" data-trim data-noescape data-line-numbers>
          class CompiledItems {

              protected const ITEMS = [
                  'thing1' => [
                      'color' => 'blue',
                      'size' => 5,
                  ],
                  'thing2' => [
                      'color' => 'green',
                      'size' => 7,
                  ],
              ];

              public function getItem(string $name) {
                  return new Item(static::ITEMS[$name]);
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Embedded into shared memory, not process memory</li>
            <li>More efficient if you just lookup rather than copy into memory</li>
            <li>Use objects to build the data that will be serialized that way</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <h3>So really, Never* Use Arrays</h3>
      <p class="fragment oversize">(in public)</p>
    </section>

    <section id="final">
      <h2>Larry Garfield</h2>
      <h2><a href="http://twitter.com/Crell">@Crell</a></h2>
      <p>Director of Developer Experience <a href="http://www.platform.sh/">Platform.sh</a></p>
      <p>Idea to Cloud Hosting</p>
      <p>Stalk us at <a href="http://twitter.com/Platformsh">@PlatformSH</a></p>
    </section>
  </div>
</div>

<script src="js/reveal.js"></script>

<script>
	// More info about config & dependencies:
	// - https://github.com/hakimel/reveal.js#configuration
	// - https://github.com/hakimel/reveal.js#dependencies
	Reveal.initialize({
    hash: true,
    controlsTutorial: false,
		dependencies: [
			{ src: 'plugin/markdown/marked.js' },
			{ src: 'plugin/markdown/markdown.js' },
			{ src: 'plugin/notes/notes.js', async: true },
			{ src: 'plugin/highlight/highlight.js', async: true }
		]
	});
</script>

<!-- Custom Reveal extension scripts. -->
<script src="platform/classer.js"></script>
<script src="platform/countup.js"></script>
<script src="platform/usecase.js"></script>

</body>
</html>
